<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sowilo - Computer vision for OCaml | raven</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <main class="main-content">
    <nav class="sowilo-nav nav-breadcrumb">
      <a href="/">raven</a> / sowilo <span class="color-indigo rune-symbol">ᛋ</span>
      [ <a href="/docs/sowilo/">docs</a> |
      <a href="https://github.com/raven-ml/raven/tree/main/sowilo">source</a> ]
    </nav>

    <div class="sowilo-hero hero">
      <h1>sowilo <span style="font-size: 48px; margin-left: -20px; opacity: 0.6;" class="color-indigo">ᛋ</span></h1>
      <p class="tagline">OpenCV's algorithms. torchvision's autodiff. OCaml's reliability.</p>
    </div>

    <hr>

    <h2>why sowilo?</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-indigo">differentiable vision</h3>
        <p>Every operation supports automatic differentiation. Train neural networks with classical CV in the loop.</p>
      </div>
      <div>
        <h3 class="color-indigo">pure functional</h3>
        <p>No global state, no side effects. Image processing operations that compose like functions should.</p>
      </div>
      <div>
        <h3 class="color-indigo">type-safe images</h3>
        <p>Images are just tensors with known shapes. The compiler catches dimension mismatches.</p>
      </div>
      <div>
        <h3 class="color-indigo">jit ready</h3>
        <p>Built on Rune's tensor operations. When JIT lands, your filters compile to GPU kernels automatically.</p>
      </div>
    </div>

    <hr>

    <h2>show me the code</h2>

    <div class="code-compare">
      <div>
        <h4>OpenCV</h4>
        <pre class="language-python"><code class="language-python">import cv2
import numpy as np

# Load and process
img = cv2.imread('photo.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
blurred = cv2.GaussianBlur(gray, (5, 5), 1.0)
edges = cv2.Canny(blurred, 100, 200)

# Not differentiable!</code></pre>
      </div>
      <div>
        <h4>SOWILO</h4>
        <pre class="language-ocaml"><code class="language-ocaml">open Sowilo

(* Load and process *)
let img = Nx_io.load_image "photo.jpg" |> Rune.of_bigarray
let processed = 
  img
  |> to_grayscale
  |> gaussian_blur ~ksize:5 ~sigma:1.0
  |> canny ~low:100. ~high:200.

(* Fully differentiable! *)</code></pre>
      </div>
    </div>

    <hr>

    <h2>image processing operations</h2>

    <pre class="language-ocaml"><code class="language-ocaml">(* Filters *)
gaussian_blur img ~ksize:5 ~sigma:1.0
median_blur img ~ksize:3
box_filter img ~ksize:3

(* Edge detection *)
let grad_x, grad_y = sobel img ~dx:1 ~dy:0 ~ksize:3
let edges = canny img ~low:50. ~high:150.

(* Morphology *)
let kernel = get_structuring_element Rect ~ksize:3
let eroded = erode img kernel
let dilated = dilate img kernel

(* Thresholding *)
threshold img ~thresh:128. ~maxval:255. ~typ:Binary</code></pre>

    <hr>

    <h2>differentiable augmentations</h2>

    <p>Train neural networks with classical CV operations in the forward pass:</p>

    <pre class="language-ocaml"><code class="language-ocaml">(* Augmentation pipeline *)
let augment img =
  img
  |> random_crop ~size:(224, 224)
  |> random_flip ~p:0.5
  |> adjust_brightness ~factor:(random 0.8 1.2)
  |> gaussian_blur ~ksize:3 ~sigma:(random 0. 1.)

(* Use in training - gradients flow through! *)
let loss model img label =
  let augmented = augment img in
  let features = extract_features augmented in
  let pred = Model.forward model features in
  cross_entropy pred label</code></pre>

    <hr>

    <h2>what's implemented</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-indigo">core operations</h3>
        <ul style="list-style: none; padding: 0;">
          <li>✓ Color space conversions</li>
          <li>✓ Gaussian, median, box filters</li>
          <li>✓ Sobel gradients, Canny edges</li>
          <li>✓ Morphological operations</li>
          <li>✓ Thresholding functions</li>
          <li>✓ Image resizing (nearest, bilinear)</li>
        </ul>
      </div>
      <div>
        <h3 class="color-indigo">coming soon</h3>
        <ul style="list-style: none; padding: 0;">
          <li>⏳ Feature detection (SIFT, ORB)</li>
          <li>⏳ Optical flow</li>
          <li>⏳ Semantic segmentation ops</li>
          <li>⏳ Video processing</li>
          <li>⏳ 3D vision primitives</li>
        </ul>
      </div>
    </div>

    <hr>

    <h2>design philosophy</h2>

    <p><b>Images are tensors.</b> No special image type - just 3D arrays with shape [H; W; C]. This means any tensor operation works on images.</p>

    <p><b>Everything differentiates.</b> Unlike traditional CV libraries, every operation in sowilo can be differentiated. This enables new techniques like learnable image processing.</p>

    <p><b>Functional composition.</b> Operations are pure functions that compose naturally. No global state, no side effects.</p>

    <hr>

    <h2>get started</h2>

    <p>Sowilo isn't released yet. For now, check out the <a href="/docs/sowilo/">documentation</a> to learn more.</p>

    <p>When it's ready:</p>

    <pre class="language-bash"><code class="language-bash">opam install sowilo</code></pre>

    <pre class="language-ocaml"><code class="language-ocaml">open Sowilo

(* Edge detection example *)
let () =
  let img = Nx_io.load_image "input.jpg" in
  let edges =
    Rune.of_bigarray (Nx.to_bigarray img)
    |> to_grayscale
    |> canny ~low:50. ~high:150.
    |> Rune.to_bigarray
    |> Nx.of_bigarray
  in
  Nx_io.save_image edges "edges.png"</code></pre>
  </main>

</body>
</html>