<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>sowilo - Computer vision for OCaml | raven</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <main class="main-content">
    <nav class="sowilo-nav nav-breadcrumb">
      <a href="/">raven</a> / sowilo <span class="color-indigo rune-symbol">&#5835;</span>
      [ <a href="/docs/sowilo/">docs</a> |
      <a href="https://github.com/raven-ml/raven/tree/main/sowilo">source</a> ]
    </nav>

    <div class="sowilo-hero hero">
      <h1>sowilo <span style="font-size: 48px; margin-left: -20px; opacity: 0.6;" class="color-indigo">&#5835;</span></h1>
      <p class="tagline">OpenCV's toolkit. Differentiable by default. Pure Rune tensors.</p>
    </div>

    <hr>

    <h2>why sowilo?</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-indigo">differentiable by default</h3>
        <p>Built on Rune tensor operations. Gradients flow through blurs, color transforms, and geometric ops. Train neural networks with classical CV in the loop.</p>
      </div>
      <div>
        <h3 class="color-indigo">pure tensor operations</h3>
        <p>No special image type. Images are <code>[H; W; C]</code> tensors. Every operation composes with <code>|></code>, works with <code>Rune.grad</code>, <code>Rune.jit</code>, and <code>Rune.vmap</code>.</p>
      </div>
      <div>
        <h3 class="color-indigo">complete toolkit</h3>
        <p>Filters, edge detection, morphology, color adjustment, geometric transforms, and thresholding. Everything you need for image processing pipelines.</p>
      </div>
      <div>
        <h3 class="color-indigo">batch ready</h3>
        <p>All operations handle both single images <code>[H; W; C]</code> and batches <code>[N; H; W; C]</code>. Process entire datasets in one call.</p>
      </div>
    </div>

    <hr>

    <h2>show me the code</h2>

    <div class="code-compare">
      <div>
        <h4>OPENCV</h4>
        <pre class="language-python"><code class="language-python">import cv2
import numpy as np

# Load and convert
img = cv2.imread("photo.png")
img = img.astype(np.float32) / 255.0
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Process
blurred = cv2.GaussianBlur(
    gray, (0, 0), sigmaX=1.0
)
edges = cv2.Canny(
    (blurred * 255).astype(np.uint8),
    50, 150
)

# Not differentiable!</code></pre>
      </div>
      <div>
        <h4>SOWILO</h4>
        <pre class="language-ocaml"><code class="language-ocaml">open Sowilo

(* Load and convert *)
let img =
  Nx_io.load_image "photo.png"
  |> to_float

let gray = to_grayscale img

(* Process *)
let blurred =
  gaussian_blur ~sigma:1.0 gray

let edges =
  canny ~low:0.2 ~high:0.6 gray

(* Fully differentiable! *)</code></pre>
      </div>
    </div>

    <hr>

    <h2>image processing operations</h2>

    <pre class="language-ocaml"><code class="language-ocaml">(* Spatial filters *)
let smooth = gaussian_blur ~sigma:1.0 img
let averaged = box_blur ~ksize:5 img
let denoised = median_blur ~ksize:3 img
let sharp = unsharp_mask ~sigma:1.0 ~amount:1.5 img
let custom = filter2d my_kernel img

(* Edge detection *)
let gx, gy = sobel gray           (* horizontal and vertical gradients *)
let gx, gy = scharr gray          (* more accurate than Sobel *)
let lap = laplacian gray           (* sum of second derivatives *)
let edges = canny ~low:0.2 ~high:0.6 gray

(* Morphology *)
let kernel = structuring_element Rect (5, 5)
let eroded = erode ~kernel img
let dilated = dilate ~kernel img
let opened = opening ~kernel img
let grad = morphological_gradient ~kernel img

(* Color and adjustment *)
let gray = to_grayscale img
let hsv = rgb_to_hsv img
let bright = adjust_brightness 1.2 img
let contrasted = adjust_contrast 1.5 img

(* Geometric transforms *)
let small = resize ~height:224 ~width:224 img
let cropped = center_crop ~height:200 ~width:200 img
let flipped = hflip img
let rotated = rotate90 ~k:2 img</code></pre>

    <hr>

    <h2>differentiable pipelines</h2>

    <p>Sowilo operations compose naturally and gradients flow through the entire pipeline:</p>

    <pre class="language-ocaml"><code class="language-ocaml">(* Preprocessing for a neural network *)
let preprocess img =
  img
  |> to_float
  |> resize ~height:224 ~width:224
  |> normalize
      ~mean:[0.485; 0.456; 0.406]
      ~std:[0.229; 0.224; 0.225]

(* Differentiable augmentation *)
let augment img =
  img
  |> adjust_brightness 1.1
  |> adjust_contrast 0.9
  |> gaussian_blur ~sigma:0.5

(* Use in training - gradients flow through! *)
let loss params img label =
  let pred = model params (preprocess (augment img)) in
  cross_entropy pred label</code></pre>

    <hr>

    <h2>what's implemented</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-indigo">filters</h3>
        <ul>
          <li>&#10003; gaussian_blur</li>
          <li>&#10003; box_blur</li>
          <li>&#10003; median_blur</li>
          <li>&#10003; filter2d</li>
          <li>&#10003; unsharp_mask</li>
        </ul>
      </div>
      <div>
        <h3 class="color-indigo">edge detection</h3>
        <ul>
          <li>&#10003; sobel (returns gx, gy)</li>
          <li>&#10003; scharr</li>
          <li>&#10003; laplacian</li>
          <li>&#10003; canny</li>
        </ul>
        <h3 class="color-indigo">morphology</h3>
        <ul>
          <li>&#10003; erode, dilate</li>
          <li>&#10003; opening, closing</li>
          <li>&#10003; morphological_gradient</li>
        </ul>
      </div>
      <div>
        <h3 class="color-indigo">color</h3>
        <ul>
          <li>&#10003; to_grayscale</li>
          <li>&#10003; rgb_to_hsv / hsv_to_rgb</li>
          <li>&#10003; brightness, contrast</li>
          <li>&#10003; saturation, hue, gamma</li>
          <li>&#10003; invert</li>
        </ul>
      </div>
      <div>
        <h3 class="color-indigo">transforms</h3>
        <ul>
          <li>&#10003; resize (nearest, bilinear)</li>
          <li>&#10003; crop, center_crop</li>
          <li>&#10003; hflip, vflip</li>
          <li>&#10003; rotate90</li>
          <li>&#10003; pad</li>
          <li>&#10003; to_float / to_uint8</li>
          <li>&#10003; normalize, threshold</li>
        </ul>
      </div>
    </div>

    <hr>

    <h2>the good parts</h2>

    <p><b>Images are tensors.</b>
    No special image type. An image is a <code>[H; W; C]</code> float32 tensor with values in [0, 1]. This means any Rune operation works on images, and any sowilo operation is just a tensor function.</p>

    <p><b>Gradients flow through.</b>
    Most operations are differentiable because they are built from standard tensor operations. Use <code>Rune.grad</code> to compute gradients through blurs, color adjustments, resizing, and more. Only <code>canny</code> and <code>median_blur</code> break the gradient.</p>

    <p><b>Functional composition.</b>
    Operations are pure functions. Pipe them with <code>|></code>, compose them into pipelines, use them inside <code>Rune.grad</code> or <code>Rune.jit</code>. No global state, no side effects.</p>

    <hr>

    <h2>get started</h2>

    <p>Sowilo is part of the Raven ecosystem. When it's released:</p>

    <pre class="language-bash"><code class="language-bash">opam install sowilo</code></pre>

    <pre class="language-ocaml"><code class="language-ocaml">open Sowilo

let () =
  (* Load and convert to float32 [0, 1] *)
  let img = Nx_io.load_image "photo.png" |> to_float in

  (* Detect edges *)
  let gray = to_grayscale img in
  let edges = canny ~low:0.2 ~high:0.6 gray in

  (* Save result *)
  let result = to_uint8 edges in
  Nx_io.save_image result "edges.png"</code></pre>

    <p>For now, check out the <a href="/docs/sowilo/">documentation</a> to learn more.</p>
  </main>

</body>
</html>
