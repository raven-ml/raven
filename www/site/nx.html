<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>nx - N-dimensional arrays for OCaml | raven</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <main class="main-content">
    <nav class="nx-nav nav-breadcrumb">
      <a href="/">raven</a> / nx
      [ <a href="/docs/nx/">docs</a> |
      <a href="https://github.com/raven-ml/raven/tree/main/nx">source</a> ]
    </nav>

    <div class="nx-hero hero">
      <h1>nx</h1>
      <p class="tagline">NumPy's power. OCaml's type safety. Zero compromises.</p>
    </div>

    <hr>

    <h2>why nx?</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-blue">your numpy code, but safer</h3>
        <p>The API feels like NumPy because it is like NumPy. But the compiler catches your dimension mismatches.</p>
      </div>
      <div>
        <h3 class="color-blue">actually zero-copy</h3>
        <p>Slicing returns views. Broadcasting doesn't allocate. Reshaping is free. We mean it.</p>
      </div>
      <div>
        <h3 class="color-blue">backends that matter</h3>
        <p>CPU today. Metal on macOS. CUDA coming. Same code runs everywhere.</p>
      </div>
      <div>
        <h3 class="color-blue">part of something bigger</h3>
        <p>First-class citizen in Raven. Your arrays flow seamlessly into plotting, autodiff, and neural networks.</p>
      </div>
    </div>

    <hr>

    <h2>show me the code</h2>

    <div class="code-compare">
      <div>
        <h4>NUMPY</h4>
        <pre class="language-python"><code class="language-python"># Create and reshape
a = np.arange(12).reshape(3, 4)

# Slice (might copy)
b = a[:, 1:3]

# Reduction
c = a.mean(axis=0)

# This crashes at runtime
x = np.ones((2, 3))
y = np.ones((3, 2))
z = x + y  # ValueError!</code></pre>
      </div>
      <div>
        <h4>NX</h4>
        <pre class="language-ocaml"><code class="language-ocaml">(* Create and reshape *)
let a = arange 12 |> reshape [|3; 4|]

(* Slice (never copies) *)
let b = get_slice [All; R [1; 3]] a

(* Reduction *)
let c = mean ~axes:[|0|] a

(* This would fail at compile time *)
let x = ones float32 [|2; 3|]
let y = ones float32 [|3; 2|]
(* let z = add x y  -- won't compile! *)</code></pre>
      </div>
    </div>

    <hr>

    <h2>the good parts</h2>

    <p><b>Types that work</b><br>
    float32, float64, int32, int64, uint8, and more. Generic functions that preserve types.</p>

    <p><b>Broadcasting that makes sense</b><br>
    [|3; 1; 5|] + [|1; 4; 5|] = [|3; 4; 5|]. Same rules as NumPy.</p>

    <p><b>I/O that just works</b><br>
    Load your .npy files. Save as images. Interop with Python when you need to.</p>

    <hr>

    <h2>get started</h2>

    <p>Nx isn't released yet. For now, check out the <a href="/docs/nx/">documentation</a> to learn more.</p>

    <p>When it's ready:</p>

    <pre class="language-bash"><code class="language-bash">opam install nx</code></pre>

    <pre class="language-ocaml"><code class="language-ocaml">open Nx

let () =
  let x = rand float32 [|3; 3|] in
  print_tensor x</code></pre>
  </main>

</body>
</html>