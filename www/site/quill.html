<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>quill - Plain markdown notebooks for OCaml | raven</title>
  <link rel="stylesheet" href="/styles.css">
</head>
<body>
  <main class="main-content">
    <nav class="quill-nav nav-breadcrumb">
      <a href="/">raven</a> / quill
      [ <a href="/docs/quill/">docs</a> |
      <a href="https://github.com/raven-ml/raven/tree/main/quill">source</a> ]
    </nav>

    <div class="quill-hero hero">
      <h1>quill</h1>
      <p class="tagline">Plain markdown notebooks. Run them in your terminal.</p>
    </div>

    <hr>

    <h2>why quill?</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-green">plain markdown</h3>
        <p>Your notebooks are <code>.md</code> files. Write in any editor, diff with git, read on GitHub. No JSON, no binary formats, no lock-in.</p>
      </div>
      <div>
        <h3 class="color-green">terminal native</h3>
        <p>A full-screen TUI for navigating cells, executing code, and viewing results. No browser required. Works over SSH.</p>
      </div>
      <div>
        <h3 class="color-green">watch mode</h3>
        <p>Edit in your favorite editor while <code>quill eval --watch --inplace</code> re-executes and updates outputs automatically.</p>
      </div>
      <div>
        <h3 class="color-green">raven integrated</h3>
        <p>Nx, Rune, Kaun, Hugin, Sowilo, Talon, Brot, and Fehu are pre-loaded. Start computing immediately.</p>
      </div>
    </div>

    <hr>

    <h2>show me the code</h2>

    <div class="code-compare">
      <div>
        <h4>JUPYTER (.ipynb)</h4>
        <pre class="language-json"><code class="language-json">{
  "cells": [
    {
      "cell_type": "markdown",
      "source": ["# Analysis\n",
                  "Let's compute:"]
    },
    {
      "cell_type": "code",
      "source": ["x = 2 + 2\n",
                  "print(f'{x}')"],
      "metadata": {},
      "execution_count": 1,
      "outputs": [{
        "output_type": "stream",
        "name": "stdout",
        "text": ["4\n"]
      }]
    }
  ],
  "metadata": { "kernelspec": { ... } }
}</code></pre>
      </div>
      <div>
        <h4>QUILL (.md)</h4>
        <pre class="language-markup"><code class="language-markup"># Analysis

Let's compute:

```ocaml
let x = 2 + 2
let () = Printf.printf "%d\n" x
```</code></pre>
      </div>
    </div>

    <p>One is a JSON blob. The other is a document you can read.</p>

    <hr>

    <h2>the workflow</h2>

    <p>Write a markdown file with OCaml code blocks:</p>

    <pre class="language-markup"><code class="language-markup"># My Analysis

Some introductory text.

```ocaml
open Nx

let data = linspace float32 0. 10. 100
let () = Printf.printf "Shape: %s\n" (shape_to_string data)
```

Now compute statistics:

```ocaml
let m = mean data
let () = Printf.printf "Mean: %s\n" (to_string m)
```</code></pre>

    <p>Three ways to run it:</p>

    <pre class="language-bash"><code class="language-bash"># Interactive TUI — navigate cells, execute, view results
quill notebook.md

# Batch — execute all cells, print to stdout
quill eval notebook.md

# Live editing — edit in vim, outputs update on every save
quill eval --watch --inplace notebook.md</code></pre>

    <hr>

    <h2>what's implemented</h2>

    <div class="feature-grid">
      <div>
        <h3 class="color-green">notebook format</h3>
        <ul>
          <li>CommonMark parsing</li>
          <li>Outputs as HTML comments</li>
          <li>Stable cell identifiers</li>
          <li>Output stripping with <code>quill fmt</code></li>
          <li>Roundtrip-safe serialization</li>
        </ul>
      </div>
      <div>
        <h3 class="color-green">terminal UI</h3>
        <ul>
          <li>Cell navigation (j/k, arrows)</li>
          <li>Execute cell (Enter) or all (Ctrl-A)</li>
          <li>Insert, delete, move, toggle cells</li>
          <li>Syntax highlighting</li>
          <li>Auto-reload on external edits</li>
        </ul>
      </div>
      <div>
        <h3 class="color-green">execution</h3>
        <ul>
          <li>In-process OCaml toplevel</li>
          <li>Persistent state across cells</li>
          <li>Stdout/stderr/error capture</li>
          <li>Rich display output (MIME)</li>
          <li>Interrupt with Ctrl-C</li>
        </ul>
      </div>
      <div>
        <h3 class="color-green">CLI</h3>
        <ul>
          <li><code>quill eval</code> batch execution</li>
          <li><code>--inplace</code> write outputs back</li>
          <li><code>--watch</code> re-execute on change</li>
          <li><code>quill fmt</code> strip outputs</li>
          <li>All Raven packages pre-loaded</li>
        </ul>
      </div>
    </div>

    <hr>

    <h2>design philosophy</h2>

    <p><b>Notebooks are documents.</b> A notebook is a markdown file. You can edit it in any text editor, version it with git, and read it on GitHub. The file format should never get in your way.</p>

    <p><b>The terminal is enough.</b> You don't need a browser to run a notebook. The TUI gives you cell navigation, execution, and output display in any terminal. SSH into a server and run your notebooks there.</p>

    <hr>

    <h2>get started</h2>

    <p>Quill isn't released yet. For now, check out the <a href="/docs/quill/">documentation</a> to learn more.</p>

    <p>When it's ready:</p>

    <pre class="language-bash"><code class="language-bash">opam install quill

# Create a notebook
cat > hello.md <<'EOF'
# Hello

```ocaml
let () = Printf.printf "Hello from Quill!\n"
```
EOF

# Open in the TUI
quill hello.md

# Or evaluate from the command line
quill eval hello.md</code></pre>
  </main>

</body>
</html>
