(*---------------------------------------------------------------------------
  Copyright (c) 2026 The Raven authors. All rights reserved.
  SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Adapted from ocaml-crunch (https://github.com/mirage/ocaml-crunch) *)

module String_map = Map.Make (String)

type file_entry = {
  chunk_digests : string list;
  file_digest : string;
  size : int;
}

type t = {
  chunks : string String_map.t; (* Map: digest -> content *)
  files : file_entry String_map.t; (* Map: filename -> entry *)
}

let empty = { chunks = String_map.empty; files = String_map.empty }

(* File System Walking *)

let walk_directory_tree exts walkfn root_dir t =
  let rec walk_dir dir rel_path t =
    let dh = Unix.opendir dir in
    let rec loop t =
      match Unix.readdir dh with
      | exception End_of_file -> t
      | "." | ".." -> loop t
      | f ->
          let n = Filename.concat dir f in
          let rel = Filename.concat rel_path f in
          if Sys.is_directory n then loop (walk_dir n rel t)
          else
            let name = rel in
            (* Extension Filtering *)
            let should_include =
              match exts with
              | [] -> true
              | _ ->
                  let ext = Filename.extension f in
                  if String.length ext > 0 then
                    (* remove dot *)
                    let ext_clean = String.sub ext 1 (String.length ext - 1) in
                    List.mem ext_clean exts
                  else false
            in
            if should_include then loop (walkfn t root_dir name) else loop t
    in
    let result = loop t in
    Unix.closedir dh;
    result
  in
  walk_dir root_dir "" t

(* Chunking Logic *)

let scan_file t root name =
  let full_name = Filename.concat root name in
  let ic = open_in_bin full_name in
  let len = in_channel_length ic in
  let buffer_size = 4096 in
  let buffer = Bytes.create buffer_size in

  let rec read_chunks chunks_acc =
    match input ic buffer 0 buffer_size with
    | 0 -> List.rev chunks_acc
    | n ->
        let s = Bytes.sub_string buffer 0 n in
        let digest = Digest.to_hex (Digest.string s) in
        read_chunks ((digest, s) :: chunks_acc)
  in

  let chunks_raw = read_chunks [] in
  close_in ic;

  (* Update Structure *)
  let new_chunks_map =
    List.fold_left
      (fun acc (dig, content) ->
        match String_map.find_opt dig acc with
        | None -> String_map.add dig content acc
        | Some existing ->
            if existing <> content then
              failwith
                (Printf.sprintf "Hash collision on chunk %s in file %s" dig name)
            else acc)
      t.chunks chunks_raw
  in

  let chunk_digests = List.map fst chunks_raw in

  (* Calculate full file digest from the concatenation of chunks to match legacy
     behavior or just hash the whole file. Here we re-hash the chunks for
     simplicity. *)
  let full_content = String.concat "" (List.map snd chunks_raw) in
  let file_digest = Digest.to_hex (Digest.string full_content) in

  let entry = { chunk_digests; file_digest; size = len } in
  { chunks = new_chunks_map; files = String_map.add name entry t.files }

(* Code Generation *)

let header binary =
  Printf.sprintf
    "(* Generated by: %s *)\n\
     (* This file is generated. Do not edit directly. *)\n\n"
    binary

let static_reader_impl =
  {|
(** Internal implementation of efficient partial reading *)
module Reader = struct
  let rec read_range chunks cur_pos target_start target_end acc =
    match chunks with
    | [] -> List.rev acc
    | chunk :: rest ->
        let chunk_len = String.length chunk in
        let chunk_end = cur_pos + chunk_len in
        
        (* Optimization: Skip chunks completely before the start *)
        if chunk_end <= target_start then
          read_range rest chunk_end target_start target_end acc
        (* Optimization: Stop if we are completely past the end *)
        else if cur_pos >= target_end then
          List.rev acc
        else
          (* Overlap detected *)
          let slice_start_rel = max 0 (target_start - cur_pos) in
          let slice_end_rel = min chunk_len (target_end - cur_pos) in
          let len = slice_end_rel - slice_start_rel in
          
          let slice = 
            if len = chunk_len then chunk 
            else String.sub chunk slice_start_rel len 
          in
          read_range rest chunk_end target_start target_end (slice :: acc)
end
|}

let output_ml t oc binary =
  let pf fmt = Printf.fprintf oc fmt in
  pf "%s" (header binary);

  (* Internal Module containing raw data *)
  pf "module Internal = struct\n";
  pf "  (* Chunk definitions *)\n";
  String_map.iter
    (fun hash content -> pf "  let c_%s = %S\n" hash content)
    t.chunks;

  pf "\n  (* File to chunk mapping *)\n";
  pf "  let file_chunks = function\n";
  String_map.iter
    (fun name { chunk_digests; _ } ->
      pf "    | %S -> Some [" name;
      List.iter (fun d -> pf "c_%s; " d) chunk_digests;
      pf "]\n")
    t.files;
  pf "    | _ -> None\n";

  pf "\n  let file_list = [\n";
  String_map.iter (fun name _ -> pf "    %S;\n" name) t.files;
  pf "  ]\n";
  pf "end\n\n";

  (* Helper Logic *)
  pf "%s\n" static_reader_impl;

  (* Public API *)
  pf "let file_list = Internal.file_list\n\n";

  pf "let size = function\n";
  String_map.iter
    (fun name { size; _ } -> pf "  | %S -> Some %d\n" name size)
    t.files;
  pf "  | _ -> None\n\n";

  pf "let hash = function\n";
  String_map.iter
    (fun name { file_digest; _ } -> pf "  | %S -> Some %S\n" name file_digest)
    t.files;
  pf "  | _ -> None\n\n";

  pf "let read_range name ?(offset=0) ?len () = \n";
  pf "  match Internal.file_chunks name with\n";
  pf "  | None -> None\n";
  pf "  | Some chunks ->\n";
  pf "      let total_size = match size name with Some s -> s | None -> 0 in\n";
  pf
    "      let len = match len with Some l -> l | None -> total_size - offset in\n";
  pf "      if offset < 0 || len < 0 || offset + len > total_size then None\n";
  pf "      else\n";
  pf
    "        let slices = Reader.read_range chunks 0 offset (offset + len) [] in\n";
  pf "        Some (String.concat \"\" slices)\n\n";

  pf "let read name = read_range name ~offset:0 ()\n"

let output_mli oc binary =
  let pf fmt = Printf.fprintf oc fmt in
  pf "%s" (header binary);
  pf
    {|
(** [file_list] is the list of all files in the store *)
val file_list : string list

(** [size name] returns the size of the file in bytes, or None if not found *)
val size : string -> int option

(** [hash name] returns the MD5 hash of the file, or None if not found *)
val hash : string -> string option

(** [read name] returns the full content of the file, or None if not found *)
val read : string -> string option

(** [read_range name ?offset ?len ()] returns a specific substring of the file.
    It constructs the result efficiently from chunks without allocating the 
    whole file. 
    Defaults: [offset] = 0, [len] = remaining bytes. *)
val read_range : string -> ?offset:int -> ?len:int -> unit -> string option
|}

(* Argument Parsing *)

let () =
  let dirs = ref [] in
  let exts = ref [] in
  let output = ref "generated.ml" in
  let silent = ref false in

  let spec =
    [
      ("-o", Arg.Set_string output, "OUTPUT Output file (default: generated.ml)");
      ( "-e",
        Arg.String (fun s -> exts := s :: !exts),
        "EXT Include only specific extensions (e.g. 'txt')" );
      ("-s", Arg.Set silent, " Silent mode");
    ]
  in

  let usage = "Usage: ocaml-crunch [options] <directories...>" in

  Arg.parse spec (fun s -> dirs := s :: !dirs) usage;

  if !dirs = [] then (
    Arg.usage spec usage;
    exit 1);

  let binary = Sys.argv.(0) in
  let dirs = List.rev !dirs in
  let exts = List.rev !exts in

  if not !silent then Printf.printf "Scanning directories...\n%!";

  let t =
    List.fold_left
      (fun t dir -> walk_directory_tree exts scan_file dir t)
      empty dirs
  in

  if not !silent then Printf.printf "Generating %s...\n%!" !output;

  let oc = open_out !output in
  output_ml t oc binary;
  close_out oc;

  (* Optional: Generate .mli if output ends in .ml *)
  if Filename.check_suffix !output ".ml" then (
    let mli = Filename.chop_suffix !output ".ml" ^ ".mli" in
    if not !silent then Printf.printf "Generating %s...\n%!" mli;
    let oc_mli = open_out mli in
    output_mli oc_mli binary;
    close_out oc_mli)
