open Alcotest

(* Helper functions *)
let temp_file prefix suffix = Filename.temp_file prefix suffix

let read_file path =
  let ic = open_in path in
  Fun.protect
    ~finally:(fun () -> close_in ic)
    (fun () ->
      let len = in_channel_length ic in
      really_input_string ic len)

let numpy_savetxt_float64_fixture =
  "##alpha beta gamma\r\n"
  ^ "1.234567889999999890e+00,2.345678910000000172e+00,3.456789119999999826e+00\r\n"
  ^ "4.567891229999999858e+00,5.678912340000000114e+00,6.789123449999999949e+00\r\n"
  ^ "##generated by numpy\r\n"

let expect_safetensors_ok context = function
  | Ok v -> v
  | Error err ->
      Alcotest.failf "%s: %s" context (Safetensors.string_of_error err)

let array_approx_equal ?(eps = 1e-6) a b =
  try
    let a_flat = Nx.flatten a in
    let b_flat = Nx.flatten b in
    let diff = Nx.sub a_flat b_flat in
    let abs_diff = Nx.abs diff in
    (* Get maximum value - reshape to scalar and extract *)
    let max_diff = Nx.max abs_diff ~axes:[ 0 ] ~keepdims:false in
    let max_val = Nx.item [] max_diff in
    max_val < eps
  with _ -> false

let check_array_approx msg ?(eps = 1e-6) expected actual =
  if not (array_approx_equal ~eps expected actual) then
    Alcotest.fail (Printf.sprintf "%s: arrays not approximately equal" msg)

(* Test NPY format *)
let test_npy_save_load_float32 () =
  let test_data = Nx.arange Nx.float32 0 12 1 |> Nx.reshape [| 3; 4 |] in
  let path = temp_file "test_npy_" ".npy" in

  (* Save the data *)
  Nx_io.save_npy path test_data;

  (* Load it back *)
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.as_float32 loaded in

  (* Check shape and values *)
  check (array int) "loaded shape" [| 3; 4 |] (Nx.shape loaded_f32);
  check_array_approx "loaded values" test_data loaded_f32;

  (* Clean up *)
  Sys.remove path

let test_npy_save_load_int64 () =
  let test_data = Nx.arange Nx.int64 0 20 2 |> Nx.reshape [| 2; 5 |] in
  let path = temp_file "test_npy_" ".npy" in

  (* Save the data *)
  Nx_io.save_npy path test_data;

  (* Load it back *)
  let loaded = Nx_io.load_npy path in
  let loaded_i64 = Nx_io.as_int64 loaded in

  (* Check shape *)
  check (array int) "loaded shape" [| 2; 5 |] (Nx.shape loaded_i64);

  (* Check values *)
  for i = 0 to 1 do
    for j = 0 to 4 do
      let expected = (i * 10) + (j * 2) in
      let actual = Nx.item [ i; j ] loaded_i64 |> Int64.to_int in
      check int (Printf.sprintf "value at [%d, %d]" i j) expected actual
    done
  done;

  (* Clean up *)
  Sys.remove path

let test_npy_overwrite_protection () =
  let test_data = Nx.ones Nx.float32 [| 2; 2 |] in
  let path = temp_file "test_npy_" ".npy" in

  (* Save initial file *)
  Nx_io.save_npy path test_data;

  (* Try to save with overwrite=false - should fail *)
  let result = Nx_io.Safe.save_npy ~overwrite:false path test_data in
  check bool "overwrite protection" true (Result.is_error result);

  (* Save with overwrite=true - should succeed *)
  Nx_io.save_npy ~overwrite:true path test_data;

  (* Clean up *)
  Sys.remove path

(* Test NPZ format *)
let test_npz_save_load_multiple () =
  let weights = Nx.randn Nx.float32 [| 5; 3 |] in
  let bias = Nx.zeros Nx.float32 [| 3 |] in
  let scale = Nx.ones Nx.float64 [| 3 |] in
  let path = temp_file "test_npz_" ".npz" in

  (* Save multiple arrays *)
  Nx_io.save_npz path
    [
      ("weights", Nx_io.P weights);
      ("bias", Nx_io.P bias);
      ("scale", Nx_io.P scale);
    ];

  (* Load all back *)
  let archive = Nx_io.load_npz path in

  (* Check we got all arrays *)
  check int "number of arrays" 3 (Hashtbl.length archive);
  check bool "has weights" true (Hashtbl.mem archive "weights");
  check bool "has bias" true (Hashtbl.mem archive "bias");
  check bool "has scale" true (Hashtbl.mem archive "scale");

  (* Check shapes *)
  let loaded_weights = Hashtbl.find archive "weights" |> Nx_io.as_float32 in
  let loaded_bias = Hashtbl.find archive "bias" |> Nx_io.as_float32 in
  let loaded_scale = Hashtbl.find archive "scale" |> Nx_io.as_float64 in

  check (array int) "weights shape" [| 5; 3 |] (Nx.shape loaded_weights);
  check (array int) "bias shape" [| 3 |] (Nx.shape loaded_bias);
  check (array int) "scale shape" [| 3 |] (Nx.shape loaded_scale);

  (* Clean up *)
  Sys.remove path

let test_npz_load_member () =
  let array1 = Nx.arange Nx.float32 0 10 1 in
  let array2 = Nx.arange Nx.int32 10 20 1 in
  let array3 = Nx.ones Nx.float64 [| 2; 3 |] in
  let path = temp_file "test_npz_" ".npz" in

  (* Save arrays *)
  Nx_io.save_npz path
    [
      ("array1", Nx_io.P array1);
      ("array2", Nx_io.P array2);
      ("array3", Nx_io.P array3);
    ];

  (* Load specific members *)
  let loaded1 = Nx_io.load_npz_member ~name:"array1" path |> Nx_io.as_float32 in
  let loaded2 = Nx_io.load_npz_member ~name:"array2" path |> Nx_io.as_int32 in
  let loaded3 = Nx_io.load_npz_member ~name:"array3" path |> Nx_io.as_float64 in

  check (array int) "array1 shape" [| 10 |] (Nx.shape loaded1);
  check (array int) "array2 shape" [| 10 |] (Nx.shape loaded2);
  check (array int) "array3 shape" [| 2; 3 |] (Nx.shape loaded3);

  (* Test loading non-existent member *)
  let result = Nx_io.Safe.load_npz_member ~name:"nonexistent" path in
  check bool "missing member error" true (Result.is_error result);

  (* Clean up *)
  Sys.remove path

(* Test SafeTensors format *)

let test_txt_save_load_float32 () =
  let data = Nx.reshape [| 2; 3 |] (Nx.arange Nx.float32 0 6 1) in
  let path = temp_file "test_txt_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~out:path data;
      let loaded = Nx_io.load_txt Nx.float32 path in
      check (array int) "shape" [| 2; 3 |] (Nx.shape loaded);
      check_array_approx "values" data loaded)

let test_txt_save_load_int64 () =
  let data = Nx.reshape [| 3; 2 |] (Nx.arange Nx.int64 0 6 1) in
  let path = temp_file "test_txt_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~out:path data;
      let loaded = Nx_io.load_txt Nx.int64 path in
      check (array int) "shape" [| 3; 2 |] (Nx.shape loaded);
      for i = 0 to 2 do
        for j = 0 to 1 do
          let expected = Nx.item [ i; j ] data |> Int64.to_int in
          let actual = Nx.item [ i; j ] loaded |> Int64.to_int in
          check int (Printf.sprintf "[%d,%d]" i j) expected actual
        done
      done)

let test_txt_float_precision () =
  let value = 3.141592653589793 in
  let data = Nx.full Nx.float64 [| 1 |] value in
  let path = temp_file "test_txt_precision_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~out:path data;
      let expected = Printf.sprintf "%.18e" value in
      let content = read_file path |> String.trim in
      check string "formatted value" expected content;
      let loaded = Nx_io.load_txt Nx.float64 path in
      let loaded_value = Nx.item [ 0 ] loaded in
      check (float 1e-15) "round-trip" value loaded_value)

let test_txt_bool_roundtrip () =
  let data =
    Nx.create Nx.bool [| 2; 3 |] [| true; false; true; false; true; false |]
  in
  let path = temp_file "test_txt_bool_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~out:path data;
      let loaded = Nx_io.load_txt Nx.bool path in
      check (array int) "shape" [| 2; 3 |] (Nx.shape loaded);
      let expected = Nx.to_array data in
      let actual = Nx.to_array loaded in
      check (array bool) "values" expected actual;
      let lines =
        read_file path |> String.split_on_char '\n'
        |> List.filter_map (fun line ->
               let trimmed = String.trim line in
               if trimmed = "" then None else Some trimmed)
      in
      match lines with
      | [ first; second ] ->
          check string "row 1" "1 0 1" first;
          check string "row 2" "0 1 0" second
      | _ -> Alcotest.fail "Unexpected boolean txt contents")

let test_txt_skiprows_max_rows () =
  let data = Nx.reshape [| 3; 2 |] (Nx.arange Nx.float32 0 6 1) in
  let path = temp_file "test_txt_skip_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~header:"generated by nx" ~out:path data;
      let loaded = Nx_io.load_txt Nx.float32 path in
      check (array int) "shape" [| 3; 2 |] (Nx.shape loaded);
      check_array_approx "full load" data loaded;
      let subset = Nx_io.load_txt ~skiprows:2 ~max_rows:1 Nx.float32 path in
      check (array int) "subset shape" [| 2 |] (Nx.shape subset);
      let expected = Nx.create Nx.float32 [| 2 |] [| 2.0; 3.0 |] in
      check_array_approx "subset values" expected subset)

let test_txt_load_numpy_fixture () =
  let path = temp_file "numpy_fixture" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      let oc = open_out_bin path in
      Fun.protect
        ~finally:(fun () -> close_out oc)
        (fun () -> output_string oc numpy_savetxt_float64_fixture);
      let loaded = Nx_io.load_txt ~sep:"," ~comments:"##" Nx.float64 path in
      check (array int) "shape" [| 2; 3 |] (Nx.shape loaded);
      let expected =
        Nx.create Nx.float64 [| 2; 3 |]
          [|
            1.23456789;
            2.34567891;
            3.45678912;
            4.56789123;
            5.67891234;
            6.78912345;
          |]
      in
      check_array_approx ~eps:1e-12 "values" expected loaded)

let test_txt_save_numpy_compat () =
  let data =
    Nx.create Nx.float64 [| 2; 3 |]
      [|
        1.23456789; 2.34567891; 3.45678912; 4.56789123; 5.67891234; 6.78912345;
      |]
  in
  let path = temp_file "numpy_save_fixture" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~sep:"," ~newline:"\r\n" ~comments:"##"
        ~header:"alpha beta gamma" ~footer:"generated by numpy" ~out:path data;
      let contents = read_file path in
      check string "numpy compatible output" numpy_savetxt_float64_fixture
        contents)

let txt_tests =
  [
    test_case "Save/load txt float32" `Quick test_txt_save_load_float32;
    test_case "Save/load txt int64" `Quick test_txt_save_load_int64;
    test_case "Float precision formatting" `Quick test_txt_float_precision;
    test_case "Bool round-trip" `Quick test_txt_bool_roundtrip;
    test_case "Skip rows and max_rows" `Quick test_txt_skiprows_max_rows;
    test_case "Save numpy-compatible file" `Quick test_txt_save_numpy_compat;
    test_case "Load numpy-generated file" `Quick test_txt_load_numpy_fixture;
  ]

let test_safetensors_save_load () =
  let weights = Nx.randn Nx.float32 [| 10; 5 |] in
  let bias = Nx.zeros Nx.float32 [| 5 |] in
  let embeddings = Nx.randn Nx.float32 [| 100; 64 |] in
  let path = temp_file "test_safetensors_" ".safetensors" in

  (* Save tensors *)
  Nx_io.save_safetensor path
    [
      ("model.weights", Nx_io.P weights);
      ("model.bias", Nx_io.P bias);
      ("embeddings", Nx_io.P embeddings);
    ];

  (* Load back *)
  let archive = Nx_io.load_safetensor path in

  (* Check we got all tensors *)
  check int "number of tensors" 3 (Hashtbl.length archive);
  check bool "has weights" true (Hashtbl.mem archive "model.weights");
  check bool "has bias" true (Hashtbl.mem archive "model.bias");
  check bool "has embeddings" true (Hashtbl.mem archive "embeddings");

  (* Check shapes *)
  let loaded_weights =
    Hashtbl.find archive "model.weights" |> Nx_io.as_float32
  in
  let loaded_bias = Hashtbl.find archive "model.bias" |> Nx_io.as_float32 in
  let loaded_embeddings =
    Hashtbl.find archive "embeddings" |> Nx_io.as_float32
  in

  check (array int) "weights shape" [| 10; 5 |] (Nx.shape loaded_weights);
  check (array int) "bias shape" [| 5 |] (Nx.shape loaded_bias);
  check (array int) "embeddings shape" [| 100; 64 |]
    (Nx.shape loaded_embeddings);

  (* Check values are preserved *)
  check_array_approx "weights values" weights loaded_weights;
  check_array_approx "bias values" bias loaded_bias;
  check_array_approx "embeddings values" embeddings loaded_embeddings;

  (* Clean up *)
  Sys.remove path

let test_safetensors_different_dtypes () =
  let path = temp_file "test_safetensors_dtypes_" ".safetensors" in

  (* Create arrays of different types *)
  let f32_data = Nx.arange Nx.float32 0 10 1 in
  let f64_data = Nx.arange Nx.float64 10 20 1 in
  let i32_data = Nx.arange Nx.int32 20 30 1 in

  (* Save *)
  Nx_io.save_safetensor path
    [
      ("float32_array", Nx_io.P f32_data);
      ("float64_array", Nx_io.P f64_data);
      ("int32_array", Nx_io.P i32_data);
    ];

  (* Load and verify *)
  let archive = Nx_io.load_safetensor path in

  let loaded_f32 = Hashtbl.find archive "float32_array" |> Nx_io.as_float32 in
  let loaded_f64 = Hashtbl.find archive "float64_array" |> Nx_io.as_float64 in
  let loaded_i32 = Hashtbl.find archive "int32_array" |> Nx_io.as_int32 in

  check_array_approx "float32 values" f32_data loaded_f32;
  check_array_approx "float64 values" ~eps:1e-10 f64_data loaded_f64;

  (* Check int32 values *)
  for i = 0 to 9 do
    let expected = 20 + i in
    let actual = Nx.item [ i ] loaded_i32 |> Int32.to_int in
    check int (Printf.sprintf "int32 value at [%d]" i) expected actual
  done;

  (* Clean up *)
  Sys.remove path

(* Test dtype conversions *)
let test_dtype_conversions () =
  (* Create test data *)
  let original = Nx.arange Nx.float32 0 10 1 in
  let path = temp_file "test_dtype_" ".npy" in

  (* Save and load *)
  Nx_io.save_npy path original;
  let loaded = Nx_io.load_npy path in

  (* Test successful conversion *)
  let as_f32 = Nx_io.as_float32 loaded in
  check_array_approx "float32 conversion" original as_f32;

  (* Test failing conversion (wrong dtype) *)
  let should_fail () = ignore (Nx_io.as_int32 loaded) in
  check_raises "wrong dtype conversion" (Failure "Unsupported dtype")
    should_fail;

  (* Clean up *)
  Sys.remove path

(* Test edge cases *)
let test_empty_arrays () =
  (* Empty array *)
  let empty = Nx.zeros Nx.float32 [| 0 |] in
  let path = temp_file "test_empty_" ".npy" in

  Nx_io.save_npy path empty;
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.as_float32 loaded in

  check (array int) "empty array shape" [| 0 |] (Nx.shape loaded_f32);

  (* Clean up *)
  Sys.remove path

let test_large_arrays () =
  (* Large array (but not too large for tests) *)
  let large = Nx.ones Nx.float32 [| 100; 100 |] in
  let path = temp_file "test_large_" ".npy" in

  Nx_io.save_npy path large;
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.as_float32 loaded in

  check (array int) "large array shape" [| 100; 100 |] (Nx.shape loaded_f32);

  (* Verify all values are 1 - sum and check *)
  let sum = Nx.sum loaded_f32 ~axes:[ 0; 1 ] ~keepdims:false in
  let sum_val = Nx.item [] sum in
  check (float 1e-3) "large array sum" 10000.0 sum_val;

  (* Clean up *)
  Sys.remove path

let test_high_dimensional_arrays () =
  (* 5D array *)
  let high_dim =
    Nx.arange Nx.float32 0 120 1 |> Nx.reshape [| 2; 3; 4; 5; 1 |]
  in
  let path = temp_file "test_highdim_" ".npy" in

  Nx_io.save_npy path high_dim;
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.as_float32 loaded in

  check (array int) "5D array shape" [| 2; 3; 4; 5; 1 |] (Nx.shape loaded_f32);
  check_array_approx "5D array values" high_dim loaded_f32;

  (* Clean up *)
  Sys.remove path

module Raw_safetensor = struct
  let tensor_name = "raw_tensor"

  let bytes_of_u16 values =
    let len = List.length values in
    let bytes = Bytes.create (len * 2) in
    List.iteri
      (fun i bits ->
        Bytes.set bytes (i * 2) (Char.chr (bits land 0xFF));
        Bytes.set bytes ((i * 2) + 1) (Char.chr ((bits lsr 8) land 0xFF)))
      values;
    bytes

  let write path dtype values =
    let data = Bytes.unsafe_to_string (bytes_of_u16 values) in
    let view =
      expect_safetensors_ok "tensor_view_new"
      @@ Safetensors.tensor_view_new ~dtype ~shape:[ List.length values ] ~data
    in
    expect_safetensors_ok "serialize_to_file"
    @@ Safetensors.serialize_to_file [ (tensor_name, view) ] None path

  let payload path =
    let ic = open_in_bin path in
    Fun.protect
      ~finally:(fun () -> close_in ic)
      (fun () ->
        let len = in_channel_length ic in
        let buffer = really_input_string ic len in
        let safetensors =
          expect_safetensors_ok "deserialize" @@ Safetensors.deserialize buffer
        in
        match
          Safetensors.tensors safetensors
          |> List.find_opt (fun (name, _) -> String.equal name tensor_name)
        with
        | Some (_, view) -> String.sub view.data view.offset view.length
        | None ->
            Alcotest.failf "Tensor '%s' not found in safetensors file"
              tensor_name)

  let remove path = if Sys.file_exists path then Sys.remove path

  let check_roundtrip ~dtype ~values ~payload_msg ~check_values =
    let path_in = temp_file "test_safetensors_raw_in_" ".safetensors" in
    let path_out = temp_file "test_safetensors_raw_out_" ".safetensors" in
    Fun.protect
      ~finally:(fun () ->
        remove path_in;
        remove path_out)
      (fun () ->
        write path_in dtype values;
        let archive = Nx_io.load_safetensor path_in in
        let tensor = Hashtbl.find archive tensor_name in
        check_values tensor;
        Nx_io.save_safetensor path_out [ (tensor_name, tensor) ];
        let payload_in = payload path_in in
        let payload_out = payload path_out in
        check string payload_msg payload_in payload_out)
end

(* Test SafeTensors with float16 and bfloat16 round-trip *)
let test_safetensors_float16_roundtrip () =
  let test_data = Nx.full Nx.float16 [| 2; 3 |] 1.5 in
  let path = temp_file "test_safetensors_f16_" ".safetensors" in

  (* Save the data *)
  Nx_io.save_safetensor path [ ("test_f16", Nx_io.P test_data) ];

  (* Load it back *)
  let archive = Nx_io.load_safetensor path in
  let loaded = Hashtbl.find archive "test_f16" |> Nx_io.as_float16 in

  (* Check shape and values *)
  check (array int) "float16 shape" [| 2; 3 |] (Nx.shape loaded);
  check_array_approx "float16 values" ~eps:1e-3 test_data loaded;

  (* Clean up *)
  Sys.remove path

let test_safetensors_float16_bit_exact () =
  Raw_safetensor.check_roundtrip ~dtype:Safetensors.F16
    ~values:[ 0x0000; 0x0001; 0x3C00; 0x7C00; 0x7E01 ]
    ~payload_msg:"float16 payload round-trip" ~check_values:(fun packed ->
      let values = packed |> Nx_io.as_float16 |> Nx.to_array in
      check bool "subnormal preserved" true (values.(1) <> 0.0);
      check bool "nan preserved" true (Float.is_nan values.(4)))

let test_safetensors_bfloat16_roundtrip () =
  let test_data = Nx.full Nx.bfloat16 [| 2; 3 |] 1.5 in
  let path = temp_file "test_safetensors_bf16_" ".safetensors" in

  (* Save the data *)
  Nx_io.save_safetensor path [ ("test_bf16", Nx_io.P test_data) ];

  (* Load it back *)
  let archive = Nx_io.load_safetensor path in
  let loaded = Hashtbl.find archive "test_bf16" |> Nx_io.as_bfloat16 in

  (* Check shape and values *)
  check (array int) "bfloat16 shape" [| 2; 3 |] (Nx.shape loaded);
  check_array_approx "bfloat16 values" ~eps:1e-3 test_data loaded;

  (* Clean up *)
  Sys.remove path

let test_safetensors_bfloat16_bit_exact () =
  Raw_safetensor.check_roundtrip ~dtype:Safetensors.BF16
    ~values:[ 0x0000; 0x0001; 0x3F80; 0x7F80; 0x7FC1 ]
    ~payload_msg:"bfloat16 payload round-trip" ~check_values:(fun packed ->
      let values = packed |> Nx_io.as_bfloat16 |> Nx.to_array in
      check bool "bf16 subnormal preserved" true (values.(1) <> 0.0);
      check bool "bf16 nan preserved" true (Float.is_nan values.(4)))

(* Test Safe module *)
let test_safe_module_error_handling () =
  (* Test file not found *)
  let result = Nx_io.Safe.load_npy "/nonexistent/file.npy" in
  check bool "file not found error" true (Result.is_error result);

  (* Test invalid path for save *)
  let data = Nx.ones Nx.float32 [| 2; 2 |] in
  let result = Nx_io.Safe.save_npy "/invalid/path/file.npy" data in
  check bool "invalid save path error" true (Result.is_error result);

  (* Test successful operation *)
  let path = temp_file "test_safe_" ".npy" in
  let result = Nx_io.Safe.save_npy path data in
  check bool "successful save" true (Result.is_ok result);

  let result = Nx_io.Safe.load_npy path in
  check bool "successful load" true (Result.is_ok result);

  (* Clean up *)
  Sys.remove path

let () =
  let open Alcotest in
  run "Nx_io comprehensive tests"
    [
      ( "npy",
        [
          test_case "Save/load float32" `Quick test_npy_save_load_float32;
          test_case "Save/load int64" `Quick test_npy_save_load_int64;
          test_case "Overwrite protection" `Quick test_npy_overwrite_protection;
        ] );
      ("txt", txt_tests);
      ( "npz",
        [
          test_case "Save/load multiple arrays" `Quick
            test_npz_save_load_multiple;
          test_case "Load specific member" `Quick test_npz_load_member;
        ] );
      ( "safetensors",
        [
          test_case "Save/load tensors" `Quick test_safetensors_save_load;
          test_case "Different dtypes" `Quick test_safetensors_different_dtypes;
          test_case "Float16 round-trip" `Quick
            test_safetensors_float16_roundtrip;
          test_case "Float16 bit exact" `Quick
            test_safetensors_float16_bit_exact;
          test_case "Bfloat16 round-trip" `Quick
            test_safetensors_bfloat16_roundtrip;
          test_case "Bfloat16 bit exact" `Quick
            test_safetensors_bfloat16_bit_exact;
        ] );
      ( "dtype_conversions",
        [ test_case "Basic conversions" `Quick test_dtype_conversions ] );
      ( "edge_cases",
        [
          test_case "Empty arrays" `Quick test_empty_arrays;
          test_case "Large arrays" `Quick test_large_arrays;
          test_case "High dimensional arrays" `Quick
            test_high_dimensional_arrays;
        ] );
      ( "safe_module",
        [ test_case "Error handling" `Quick test_safe_module_error_handling ] );
    ]
