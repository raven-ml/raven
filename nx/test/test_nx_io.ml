(*---------------------------------------------------------------------------
  Copyright (c) 2026 The Raven authors. All rights reserved.
  SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

open Windtrap

(* Helper functions *)
let temp_file prefix suffix = Filename.temp_file prefix suffix

let read_file path =
  let ic = open_in path in
  Fun.protect
    ~finally:(fun () -> close_in ic)
    (fun () ->
      let len = in_channel_length ic in
      really_input_string ic len)

let numpy_savetxt_float64_fixture =
  "##alpha beta gamma\r\n"
  ^ "1.234567889999999890e+00,2.345678910000000172e+00,3.456789119999999826e+00\r\n"
  ^ "4.567891229999999858e+00,5.678912340000000114e+00,6.789123449999999949e+00\r\n"
  ^ "##generated by numpy\r\n"

let read_file_bytes path =
  let ic = open_in_bin path in
  Fun.protect
    ~finally:(fun () -> close_in ic)
    (fun () ->
      let len = in_channel_length ic in
      really_input_string ic len)

let array_approx_equal ?(eps = 1e-6) a b =
  try
    let a_flat = Nx.flatten a in
    let b_flat = Nx.flatten b in
    let diff = Nx.sub a_flat b_flat in
    let abs_diff = Nx.abs diff in
    (* Get maximum value - reshape to scalar and extract *)
    let max_diff = Nx.max abs_diff ~axes:[ 0 ] ~keepdims:false in
    let max_val = Nx.item [] max_diff in
    max_val < eps
  with _ -> false

let check_array_approx msg ?(eps = 1e-6) expected actual =
  if not (array_approx_equal ~eps expected actual) then
    fail (Printf.sprintf "%s: arrays not approximately equal" msg)

(* Test NPY format *)
let test_npy_save_load_float32 () =
  let test_data = Nx.arange Nx.float32 0 12 1 |> Nx.reshape [| 3; 4 |] in
  let path = temp_file "test_npy_" ".npy" in

  (* Save the data *)
  Nx_io.save_npy path test_data;

  (* Load it back *)
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.to_typed Nx.float32 loaded in

  (* Check shape and values *)
  equal ~msg:"loaded shape" (array int) [| 3; 4 |] (Nx.shape loaded_f32);
  check_array_approx "loaded values" test_data loaded_f32;

  (* Clean up *)
  Sys.remove path

let test_npy_save_load_int64 () =
  let test_data = Nx.arange Nx.int64 0 20 2 |> Nx.reshape [| 2; 5 |] in
  let path = temp_file "test_npy_" ".npy" in

  (* Save the data *)
  Nx_io.save_npy path test_data;

  (* Load it back *)
  let loaded = Nx_io.load_npy path in
  let loaded_i64 = Nx_io.to_typed Nx.int64 loaded in

  (* Check shape *)
  equal ~msg:"loaded shape" (array int) [| 2; 5 |] (Nx.shape loaded_i64);

  (* Check values *)
  for i = 0 to 1 do
    for j = 0 to 4 do
      let expected = (i * 10) + (j * 2) in
      let actual = Nx.item [ i; j ] loaded_i64 |> Int64.to_int in
      equal ~msg:(Printf.sprintf "value at [%d, %d]" i j) int expected actual
    done
  done;

  (* Clean up *)
  Sys.remove path

let test_npy_overwrite_protection () =
  let test_data = Nx.ones Nx.float32 [| 2; 2 |] in
  let path = temp_file "test_npy_" ".npy" in

  (* Save initial file *)
  Nx_io.save_npy path test_data;

  (* Try to save with overwrite=false - should fail *)
  (try
     Nx_io.save_npy ~overwrite:false path test_data;
     fail "expected Failure for overwrite protection"
   with Failure _ -> ());

  (* Save with overwrite=true - should succeed *)
  Nx_io.save_npy ~overwrite:true path test_data;

  (* Clean up *)
  Sys.remove path

(* Test NPZ format *)
let test_npz_save_load_multiple () =
  let weights = Nx.randn Nx.float32 ~key:(Nx.Rng.key 0) [| 5; 3 |] in
  let bias = Nx.zeros Nx.float32 [| 3 |] in
  let scale = Nx.ones Nx.float64 [| 3 |] in
  let path = temp_file "test_npz_" ".npz" in

  (* Save multiple arrays *)
  Nx_io.save_npz path
    [
      ("weights", Nx_io.P weights);
      ("bias", Nx_io.P bias);
      ("scale", Nx_io.P scale);
    ];

  (* Load all back *)
  let archive = Nx_io.load_npz path in

  (* Check we got all arrays *)
  equal ~msg:"number of arrays" int 3 (Hashtbl.length archive);
  equal ~msg:"has weights" bool true (Hashtbl.mem archive "weights");
  equal ~msg:"has bias" bool true (Hashtbl.mem archive "bias");
  equal ~msg:"has scale" bool true (Hashtbl.mem archive "scale");

  (* Check shapes *)
  let loaded_weights =
    Hashtbl.find archive "weights" |> Nx_io.to_typed Nx.float32
  in
  let loaded_bias = Hashtbl.find archive "bias" |> Nx_io.to_typed Nx.float32 in
  let loaded_scale =
    Hashtbl.find archive "scale" |> Nx_io.to_typed Nx.float64
  in

  equal ~msg:"weights shape" (array int) [| 5; 3 |] (Nx.shape loaded_weights);
  equal ~msg:"bias shape" (array int) [| 3 |] (Nx.shape loaded_bias);
  equal ~msg:"scale shape" (array int) [| 3 |] (Nx.shape loaded_scale);

  (* Clean up *)
  Sys.remove path

let test_npz_load_entry () =
  let array1 = Nx.arange Nx.float32 0 10 1 in
  let array2 = Nx.arange Nx.int32 10 20 1 in
  let array3 = Nx.ones Nx.float64 [| 2; 3 |] in
  let path = temp_file "test_npz_" ".npz" in

  (* Save arrays *)
  Nx_io.save_npz path
    [
      ("array1", Nx_io.P array1);
      ("array2", Nx_io.P array2);
      ("array3", Nx_io.P array3);
    ];

  (* Load specific entries *)
  let loaded1 =
    Nx_io.load_npz_entry ~name:"array1" path |> Nx_io.to_typed Nx.float32
  in
  let loaded2 =
    Nx_io.load_npz_entry ~name:"array2" path |> Nx_io.to_typed Nx.int32
  in
  let loaded3 =
    Nx_io.load_npz_entry ~name:"array3" path |> Nx_io.to_typed Nx.float64
  in

  equal ~msg:"array1 shape" (array int) [| 10 |] (Nx.shape loaded1);
  equal ~msg:"array2 shape" (array int) [| 10 |] (Nx.shape loaded2);
  equal ~msg:"array3 shape" (array int) [| 2; 3 |] (Nx.shape loaded3);

  (* Test loading non-existent entry *)
  (try
     ignore (Nx_io.load_npz_entry ~name:"nonexistent" path);
     fail "expected Failure for missing entry"
   with Failure _ -> ());

  (* Clean up *)
  Sys.remove path

(* Test SafeTensors format *)

let test_txt_save_load_float32 () =
  let data = Nx.reshape [| 2; 3 |] (Nx.arange Nx.float32 0 6 1) in
  let path = temp_file "test_txt_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt path data;
      let loaded = Nx_io.load_txt path Nx.float32 in
      equal ~msg:"shape" (array int) [| 2; 3 |] (Nx.shape loaded);
      check_array_approx "values" data loaded)

let test_txt_save_load_int64 () =
  let data = Nx.reshape [| 3; 2 |] (Nx.arange Nx.int64 0 6 1) in
  let path = temp_file "test_txt_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt path data;
      let loaded = Nx_io.load_txt path Nx.int64 in
      equal ~msg:"shape" (array int) [| 3; 2 |] (Nx.shape loaded);
      for i = 0 to 2 do
        for j = 0 to 1 do
          let expected = Nx.item [ i; j ] data |> Int64.to_int in
          let actual = Nx.item [ i; j ] loaded |> Int64.to_int in
          equal ~msg:(Printf.sprintf "[%d,%d]" i j) int expected actual
        done
      done)

let test_txt_float_precision () =
  let value = 3.141592653589793 in
  let data = Nx.full Nx.float64 [| 1 |] value in
  let path = temp_file "test_txt_precision_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt path data;
      let expected = Printf.sprintf "%.18e" value in
      let content = read_file path |> String.trim in
      equal ~msg:"formatted value" string expected content;
      let loaded = Nx_io.load_txt path Nx.float64 in
      let loaded_value = Nx.item [ 0 ] loaded in
      equal ~msg:"round-trip" (float 1e-15) value loaded_value)

let test_txt_bool_roundtrip () =
  let data =
    Nx.create Nx.bool [| 2; 3 |] [| true; false; true; false; true; false |]
  in
  let path = temp_file "test_txt_bool_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt path data;
      let loaded = Nx_io.load_txt path Nx.bool in
      equal ~msg:"shape" (array int) [| 2; 3 |] (Nx.shape loaded);
      let expected = Nx.to_array data in
      let actual = Nx.to_array loaded in
      equal ~msg:"values" (array bool) expected actual;
      let lines =
        read_file path |> String.split_on_char '\n'
        |> List.filter_map (fun line ->
            let trimmed = String.trim line in
            if trimmed = "" then None else Some trimmed)
      in
      match lines with
      | [ first; second ] ->
          equal ~msg:"row 1" string "1 0 1" first;
          equal ~msg:"row 2" string "0 1 0" second
      | _ -> fail "Unexpected boolean txt contents")

let test_txt_skiprows_max_rows () =
  let data = Nx.reshape [| 3; 2 |] (Nx.arange Nx.float32 0 6 1) in
  let path = temp_file "test_txt_skip_" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~header:"generated by nx" path data;
      let loaded = Nx_io.load_txt path Nx.float32 in
      equal ~msg:"shape" (array int) [| 3; 2 |] (Nx.shape loaded);
      check_array_approx "full load" data loaded;
      let subset = Nx_io.load_txt ~skiprows:2 ~max_rows:1 path Nx.float32 in
      equal ~msg:"subset shape" (array int) [| 2 |] (Nx.shape subset);
      let expected = Nx.create Nx.float32 [| 2 |] [| 2.0; 3.0 |] in
      check_array_approx "subset values" expected subset)

let test_txt_load_numpy_fixture () =
  let path = temp_file "numpy_fixture" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      let oc = open_out_bin path in
      Fun.protect
        ~finally:(fun () -> close_out oc)
        (fun () -> output_string oc numpy_savetxt_float64_fixture);
      let loaded = Nx_io.load_txt ~sep:"," ~comments:"##" path Nx.float64 in
      equal ~msg:"shape" (array int) [| 2; 3 |] (Nx.shape loaded);
      let expected =
        Nx.create Nx.float64 [| 2; 3 |]
          [|
            1.23456789;
            2.34567891;
            3.45678912;
            4.56789123;
            5.67891234;
            6.78912345;
          |]
      in
      check_array_approx ~eps:1e-12 "values" expected loaded)

let test_txt_save_numpy_compat () =
  let data =
    Nx.create Nx.float64 [| 2; 3 |]
      [|
        1.23456789; 2.34567891; 3.45678912; 4.56789123; 5.67891234; 6.78912345;
      |]
  in
  let path = temp_file "numpy_save_fixture" ".txt" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path)
    (fun () ->
      Nx_io.save_txt ~sep:"," ~newline:"\r\n" ~comments:"##"
        ~header:"alpha beta gamma" ~footer:"generated by numpy" path data;
      let contents = read_file path in
      equal ~msg:"numpy compatible output" string numpy_savetxt_float64_fixture
        contents)

let txt_tests =
  [
    test "Save/load txt float32" test_txt_save_load_float32;
    test "Save/load txt int64" test_txt_save_load_int64;
    test "Float precision formatting" test_txt_float_precision;
    test "Bool round-trip" test_txt_bool_roundtrip;
    test "Skip rows and max_rows" test_txt_skiprows_max_rows;
    test "Save numpy-compatible file" test_txt_save_numpy_compat;
    test "Load numpy-generated file" test_txt_load_numpy_fixture;
  ]

let test_safetensors_save_load () =
  let weights = Nx.randn Nx.float32 ~key:(Nx.Rng.key 10) [| 10; 5 |] in
  let bias = Nx.zeros Nx.float32 [| 5 |] in
  let embeddings = Nx.randn Nx.float32 ~key:(Nx.Rng.key 11) [| 100; 64 |] in
  let path = temp_file "test_safetensors_" ".safetensors" in

  (* Save tensors *)
  Nx_io.save_safetensors path
    [
      ("model.weights", Nx_io.P weights);
      ("model.bias", Nx_io.P bias);
      ("embeddings", Nx_io.P embeddings);
    ];

  (* Load back *)
  let archive = Nx_io.load_safetensors path in

  (* Check we got all tensors *)
  equal ~msg:"number of tensors" int 3 (Hashtbl.length archive);
  equal ~msg:"has weights" bool true (Hashtbl.mem archive "model.weights");
  equal ~msg:"has bias" bool true (Hashtbl.mem archive "model.bias");
  equal ~msg:"has embeddings" bool true (Hashtbl.mem archive "embeddings");

  (* Check shapes *)
  let loaded_weights =
    Hashtbl.find archive "model.weights" |> Nx_io.to_typed Nx.float32
  in
  let loaded_bias =
    Hashtbl.find archive "model.bias" |> Nx_io.to_typed Nx.float32
  in
  let loaded_embeddings =
    Hashtbl.find archive "embeddings" |> Nx_io.to_typed Nx.float32
  in

  equal ~msg:"weights shape" (array int) [| 10; 5 |] (Nx.shape loaded_weights);
  equal ~msg:"bias shape" (array int) [| 5 |] (Nx.shape loaded_bias);
  equal ~msg:"embeddings shape" (array int) [| 100; 64 |]
    (Nx.shape loaded_embeddings);

  (* Check values are preserved *)
  check_array_approx "weights values" weights loaded_weights;
  check_array_approx "bias values" bias loaded_bias;
  check_array_approx "embeddings values" embeddings loaded_embeddings;

  (* Clean up *)
  Sys.remove path

let test_safetensors_different_dtypes () =
  let path = temp_file "test_safetensors_dtypes_" ".safetensors" in

  (* Create arrays of different types *)
  let f32_data = Nx.arange Nx.float32 0 10 1 in
  let f64_data = Nx.arange Nx.float64 10 20 1 in
  let i32_data = Nx.arange Nx.int32 20 30 1 in

  (* Save *)
  Nx_io.save_safetensors path
    [
      ("float32_array", Nx_io.P f32_data);
      ("float64_array", Nx_io.P f64_data);
      ("int32_array", Nx_io.P i32_data);
    ];

  (* Load and verify *)
  let archive = Nx_io.load_safetensors path in

  let loaded_f32 =
    Hashtbl.find archive "float32_array" |> Nx_io.to_typed Nx.float32
  in
  let loaded_f64 =
    Hashtbl.find archive "float64_array" |> Nx_io.to_typed Nx.float64
  in
  let loaded_i32 =
    Hashtbl.find archive "int32_array" |> Nx_io.to_typed Nx.int32
  in

  check_array_approx "float32 values" f32_data loaded_f32;
  check_array_approx "float64 values" ~eps:1e-10 f64_data loaded_f64;

  (* Check int32 values *)
  for i = 0 to 9 do
    let expected = 20 + i in
    let actual = Nx.item [ i ] loaded_i32 |> Int32.to_int in
    equal ~msg:(Printf.sprintf "int32 value at [%d]" i) int expected actual
  done;

  (* Clean up *)
  Sys.remove path

(* Test dtype conversions *)
let test_dtype_conversions () =
  (* Create test data *)
  let original = Nx.arange Nx.float32 0 10 1 in
  let path = temp_file "test_dtype_" ".npy" in

  (* Save and load *)
  Nx_io.save_npy path original;
  let loaded = Nx_io.load_npy path in

  (* Test successful conversion *)
  let as_f32 = Nx_io.to_typed Nx.float32 loaded in
  check_array_approx "float32 conversion" original as_f32;

  (* Test failing conversion (wrong dtype) *)
  (try
     ignore (Nx_io.to_typed Nx.int32 loaded);
     fail "expected Failure for wrong dtype"
   with Failure _ -> ());

  (* Clean up *)
  Sys.remove path

(* Test edge cases *)
let test_empty_arrays () =
  (* Empty array *)
  let empty = Nx.zeros Nx.float32 [| 0 |] in
  let path = temp_file "test_empty_" ".npy" in

  Nx_io.save_npy path empty;
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.to_typed Nx.float32 loaded in

  equal ~msg:"empty array shape" (array int) [| 0 |] (Nx.shape loaded_f32);

  (* Clean up *)
  Sys.remove path

let test_large_arrays () =
  (* Large array (but not too large for tests) *)
  let large = Nx.ones Nx.float32 [| 100; 100 |] in
  let path = temp_file "test_large_" ".npy" in

  Nx_io.save_npy path large;
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.to_typed Nx.float32 loaded in

  equal ~msg:"large array shape" (array int) [| 100; 100 |]
    (Nx.shape loaded_f32);

  (* Verify all values are 1 - sum and check *)
  let sum = Nx.sum loaded_f32 ~axes:[ 0; 1 ] ~keepdims:false in
  let sum_val = Nx.item [] sum in
  equal ~msg:"large array sum" (float 1e-3) 10000.0 sum_val;

  (* Clean up *)
  Sys.remove path

let test_high_dimensional_arrays () =
  (* 5D array *)
  let high_dim =
    Nx.arange Nx.float32 0 120 1 |> Nx.reshape [| 2; 3; 4; 5; 1 |]
  in
  let path = temp_file "test_highdim_" ".npy" in

  Nx_io.save_npy path high_dim;
  let loaded = Nx_io.load_npy path in
  let loaded_f32 = Nx_io.to_typed Nx.float32 loaded in

  equal ~msg:"5D array shape" (array int) [| 2; 3; 4; 5; 1 |]
    (Nx.shape loaded_f32);
  check_array_approx "5D array values" high_dim loaded_f32;

  (* Clean up *)
  Sys.remove path

let fixture_dir = "fixtures"

(* Extract raw tensor payload from a safetensors file *)
let safetensors_payload path =
  let buf = read_file_bytes path in
  let hdr_len =
    let get i = Int64.of_int (Char.code buf.[i]) in
    Int64.(
      to_int
        (logor (get 0)
           (logor
              (shift_left (get 1) 8)
              (logor
                 (shift_left (get 2) 16)
                 (logor
                    (shift_left (get 3) 24)
                    (logor
                       (shift_left (get 4) 32)
                       (logor
                          (shift_left (get 5) 40)
                          (logor
                             (shift_left (get 6) 48)
                             (shift_left (get 7) 56)))))))))
  in
  let start = 8 + hdr_len in
  String.sub buf start (String.length buf - start)

(* Test SafeTensors with float16 and bfloat16 round-trip *)
let test_safetensors_float16_roundtrip () =
  let test_data = Nx.full Nx.float16 [| 2; 3 |] 1.5 in
  let path = temp_file "test_safetensors_f16_" ".safetensors" in

  (* Save the data *)
  Nx_io.save_safetensors path [ ("test_f16", Nx_io.P test_data) ];

  (* Load it back *)
  let archive = Nx_io.load_safetensors path in
  let loaded = Hashtbl.find archive "test_f16" |> Nx_io.to_typed Nx.float16 in

  (* Check shape and values *)
  equal ~msg:"float16 shape" (array int) [| 2; 3 |] (Nx.shape loaded);
  check_array_approx "float16 values" ~eps:1e-3 test_data loaded;

  (* Clean up *)
  Sys.remove path

let test_safetensors_float16_bit_exact () =
  (* Fixture generated by Python: F16 bits [0x0000, 0x0001, 0x3C00, 0x7C00,
     0x7E01] = [+0, smallest subnormal, 1.0, +inf, NaN] *)
  let fixture = Filename.concat fixture_dir "f16_bit_exact.safetensors" in
  let archive = Nx_io.load_safetensors fixture in
  let packed = Hashtbl.find archive "f16_tensor" in
  let values = packed |> Nx_io.to_typed Nx.float16 |> Nx.to_array in
  equal ~msg:"subnormal preserved" bool true (values.(1) <> 0.0);
  equal ~msg:"nan preserved" bool true (Float.is_nan values.(4));
  (* Round-trip: save and check raw payload is identical *)
  let path_out = temp_file "test_f16_rt_" ".safetensors" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path_out)
    (fun () ->
      Nx_io.save_safetensors path_out [ ("f16_tensor", packed) ];
      let payload_in = safetensors_payload fixture in
      let payload_out = safetensors_payload path_out in
      equal ~msg:"float16 payload round-trip" string payload_in payload_out)

let test_safetensors_bfloat16_roundtrip () =
  let test_data = Nx.full Nx.bfloat16 [| 2; 3 |] 1.5 in
  let path = temp_file "test_safetensors_bf16_" ".safetensors" in

  (* Save the data *)
  Nx_io.save_safetensors path [ ("test_bf16", Nx_io.P test_data) ];

  (* Load it back *)
  let archive = Nx_io.load_safetensors path in
  let loaded = Hashtbl.find archive "test_bf16" |> Nx_io.to_typed Nx.bfloat16 in

  (* Check shape and values *)
  equal ~msg:"bfloat16 shape" (array int) [| 2; 3 |] (Nx.shape loaded);
  check_array_approx "bfloat16 values" ~eps:1e-3 test_data loaded;

  (* Clean up *)
  Sys.remove path

let test_safetensors_bfloat16_bit_exact () =
  (* Fixture generated by Python: BF16 bits [0x0000, 0x0001, 0x3F80, 0x7F80,
     0x7FC1] = [+0, smallest subnormal, 1.0, +inf, NaN] *)
  let fixture = Filename.concat fixture_dir "bf16_bit_exact.safetensors" in
  let archive = Nx_io.load_safetensors fixture in
  let packed = Hashtbl.find archive "bf16_tensor" in
  let values = packed |> Nx_io.to_typed Nx.bfloat16 |> Nx.to_array in
  equal ~msg:"bf16 subnormal preserved" bool true (values.(1) <> 0.0);
  equal ~msg:"bf16 nan preserved" bool true (Float.is_nan values.(4));
  (* Round-trip: save and check raw payload is identical *)
  let path_out = temp_file "test_bf16_rt_" ".safetensors" in
  Fun.protect
    ~finally:(fun () -> Sys.remove path_out)
    (fun () ->
      Nx_io.save_safetensors path_out [ ("bf16_tensor", packed) ];
      let payload_in = safetensors_payload fixture in
      let payload_out = safetensors_payload path_out in
      equal ~msg:"bfloat16 payload round-trip" string payload_in payload_out)

let () =
  run "Nx_io comprehensive tests"
    [
      group "npy"
        [
          test "Save/load float32" test_npy_save_load_float32;
          test "Save/load int64" test_npy_save_load_int64;
          test "Overwrite protection" test_npy_overwrite_protection;
        ];
      group "txt" txt_tests;
      group "npz"
        [
          test "Save/load multiple arrays" test_npz_save_load_multiple;
          test "Load specific entry" test_npz_load_entry;
        ];
      group "safetensors"
        [
          test "Save/load tensors" test_safetensors_save_load;
          test "Different dtypes" test_safetensors_different_dtypes;
          test "Float16 round-trip" test_safetensors_float16_roundtrip;
          test "Float16 bit exact" test_safetensors_float16_bit_exact;
          test "Bfloat16 round-trip" test_safetensors_bfloat16_roundtrip;
          test "Bfloat16 bit exact" test_safetensors_bfloat16_bit_exact;
        ];
      group "dtype_conversions"
        [ test "Basic conversions" test_dtype_conversions ];
      group "edge_cases"
        [
          test "Empty arrays" test_empty_arrays;
          test "Large arrays" test_large_arrays;
          test "High dimensional arrays" test_high_dimensional_arrays;
        ];
    ]
